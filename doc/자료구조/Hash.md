## Hash

- 개념
    - 특정 함수를 사용하여 얻을 수 있는 데이터와 매핑되는 값을 말하며,
      이때 사용하는 함수를 해시 함수라 한다.
    - 해시 함수는 입력값을 고정된 길이의 값으로 변환하여 출력시키는 함수이며,
      같은 입력값에 대해서는 같은 출력값을 보장한다.
    - 해시값은 데이터 색인을 위한 자료구조인 해시 맵에 사용된다.
      이는 정렬을 하지 않고도 빠른 검색과 삽입이 가능하다.

- 장점
    - 데이터의 저장과 검색연산의 복잡도가 O(1)이다.

- 단점
    -  서로 다른 입력값에 대해 동일한 출력값이 나왔을 때를 방지하기 위한 대비책이 필요하다.
       이러한 상황을 충돌 현상이라 부르며, 충돌이 자주 발생할수록 저장 및 검색연산이 O(n)에 수렴하기 때문에 이를 방지하는 것이 중요하다.
       충돌 현상을 해결하기 위한 방법으로 Separate Chaining, Open Addressing이 있다.

- 복잡도
    - 시간 복잡도
        - 저장 : O(1), 충돌이 많아질 수록 O(n)에 수렴
        - 수정 : O(1)
        - 삭제 : O(1)
    - 공간 복잡도
        - O(n)

### Hash Function

- 입력값을 고정된 길이의 값으로 변환하는 함수이다.
- 동일한 입력값에 대해 동일한 출력값을 보장한다.

### Collision

- 어떤 객체를 해시 버킷에 할당하려 했을 때 해당 버킷에 이미 다른 객체가 할당된 경우를 말한다.
    - 서로 다른 객체의 해시 값이 같은 경우
    - 서로 다른 객체의 해시 값에 나누기 연산을 적용했을 때 인덱스 값이 같은 경우
- 해시 함수를 이용하는 구현체들은  메모리를 절약하기 위하여 실제 해시 함수의 표현 정수 범위 보다 작은 M개의 원소가 있는 배열만을 사용한다.
  이와 같은 방식을 사용했을 때, 서로 다른 해시 코드를 가지는 서로 다른 객체가 1/M 확률로 같은 해시 버킷을 사용하게 된다.

#### Open Address

- 개념
    - 해시 충돌이 발생하면 다른 공간에 값을 삽입하는 방식이다.
- 방법
    1. Linear Probing (선형 탐사)
        - 다음 버킷부터 순차적으로 순회하며 비어있는 버킷을 찾는 방법이다.
    2. Quadratic probing (제곱 탐사)
        - 2의 제곱수만큼 이동하는 방식이다.
    3. Double hashing(이중 해싱)
        - 2차 해시 함수를 사용해 새로운 주소를 할당한다.
          위의 두 방법에 비해 많은 연산량을 요구한다.
    4. Rehashing (재해싱)
        - 해시 테이블의 크기를 늘린 다음
          늘어난 테이블의 크기에 맞추어 다시 해싱하는 방법이다.
- 단점
    1. 값이 저장된 버킷이 많아질수록 충돌이 빈번하게 발생한다.
    2. 충돌이 발생한 버킷을 삭제할 때에 문제가 발생할 수 있다.
       예를 들어, 충돌이 발생한 첫 번째 버킷이 삭제되면 해당 버킷과 동일한 키를 갖는 두 번째 이상의 버킷을 찾지 못한다.
       해결 방법으로는 충돌이 발생한 버킷이 삭제되면 그 버킷에 더미를 삽입하는 것이다.

#### Separate Chaining

- 개념
    - 버킷을 연결리스트 또는 트리로 구현하는 방법이다.
    - 충돌이 발생하면 충돌이 발생한 버킷이 가리키는 리스트에 노드를 추가한다.
- 단점
    - 충돌이 많이 발생하면 선형 탐색을 하기 때문에 느리다.

### Hash Table

- Key와 Value로 표현할 수 있는 데이터쌍을 저장하고 조회하는 자료구조이다.
  Key에 해시 함수를 적용한 해시값으로 저장 및 조회한다.



#### Hash Table

- JDK 1.8의 경우 index에 노드가 8개 이하인 경우에는 `LinkedList`를 사용하고 8개를 넘어갈 경우에는 트리 구조로 데이터 저장 구조를 바꾸도록 설계되어 있다.



### Map

- `HashMap`
    - 가장 일반적으로 사용하는 Map.
    - HashTable을 사용, Key값에 해시함수를 적용하여 나온 index에 Value를 저장하는 식.
    - 중복성을 허용하지 않으며, 순서가 없다는 것이 특징

- `TreeMap`
    - Red-Black Tree 자료구조를 이용한 Map이다. Tree 구조이기 때문에 어느 정도 순서를 보장한다.

- `LinkedHashMap`
    - `LinkedList`로 구현된 HashMap이다.
    -  List로 구현되어있기 때문에 순서가 보장된다.
    - 하지만 LinkedList 특성상 랜덤 접근에서 느릴 수 있다.

### Set

- `HashSet`
    - 내부적으로 `HashMap`을 사용한다. (단, dummy 파라미터에 값을 넘긴다면 내부의 Map을 `LinkedHashMap`으로 초기화한다.)
      Key는 객체, Value는 변수명이  `PRESENT` 인 Object이다.
    - 순서를 보장하지 않으며 중복값을 허용하지 않는다.
    - 주로 값의 존재여부만 확인하거나, 집합연산을 할 때 사용한다.

- `TreeSet`
    - Red-Black Tree 자료구조를 사용한 Set으로 순서를 보장한다.
- `LinkedHashSet`
    - `LinkedList`로 구현된 `HashSet`. 순서를 보장한다.



### In Java

- [Java HashMap은 어떻게 동작하는가?](